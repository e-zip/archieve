- 엔티티
    - 엔티티는 시스템의 내부 객체로서, 핵심 업무 데이터를 기반으로 동작하는 일련의 조그만 핵심 업무 규칙을 구체화.
    - 엔티티의 인터페이스는 핵심 업무 데이터를 기반으로 동작하는 핵심 업무 규칙을 구현한 함수들로 구성.
    - Actor가 필요로 하는 데이터 모델을 의미
    - 특정 '도메인'에서 사용되는 struct 모델
    - ex) Actor가 필요로하는 Movie와 MoviesPage에 관한 Entity
- 유스케이스
    - 자동화된 시스템이 동작하는 방법을 정의하고 제약함으로써 수익을 얻거나 비용을 줄이는 업무 규칙
    - 엔티티 내부 핵심 업무 규칙을 어떻게, 언제 호출할지 명시하는 규칙
        - 애플리케이션에 특화된 규칙을 설명
        - 사용자와 엔티티 사이의 상호작용을 규정
    - UI와 유스케이스는 무관하다.
    - 엔티티(고수준)는 유스케이스(저수준)에 대해서 아무것도 알지 못한다.유스케이스는 엔티티에 대해서 알고있다.
    - Use case로 들어오는 요청을 모두 같은 형태로 들어오도록 만들고, Use case로부터 응답이 나갈 때도 항상 정해진 형태로 나갈 수 있도록 함
    → 때문에 어떤 종류의 프레임워크가 붙어도 관계가 없어짐
- 인터페이스 어댑터
    - 일련의 어댑터들로 구성
    - 외부 인터페이스에서 들어오는 데이터 유즈 케이스와 엔티티에서 처리하기 편한 방식으로 변환
    - 유스케이스와 엔티티에서 나가는 데이터를 외부 인터페이스에서 처리하기 편한 방식으로 변환
    - ex. 컨트롤러, 프레젠터, 게이트웨이 등
- 프레임워크와 드라이버
    - 시스템의 핵심 업무와는 관련 없는 세부 사항이다.
    - 프레임워크나, 데이터베이스, 웹 서버 등이 여기에 해당한다.
- 종속성규칙
    - 외부 원에서 선언된 항목이 내부 원에 의해 코드에서 언급되지 않도록 지정
    - 코드 종속성은 안쪽만 가리킬 수 있음
    - 도메인 레이어 코드는 인프라 레이어 코드에 의존할 수 없음
    - 인프라 레이어 코드는 도메인 레이어 코드에 의존 가능
- 추상화원리
    - 여러 개의 객체에서 공통적이고 핵심적인 기능을 추출
    - 문제 영역, 관점에 따라 필요하지 않은 기능을 제거해 대상화하는 객체 지향 설계 원칙
    - 인터페이스(Interface)또는 추상 클래스(Abstract Class)로 구현
    - 특징
        - 문제 영역이나 관점에 의존적
        - 같은 대상이라고 하더라도 어떠한 문제 영역, 관점에서 추상화를 진행했느냐에 따라 여러 가지의 추상화 모델이 나올 수 있음
    - 장점
        - 복잡도 관리
        - 유연한 설계
        - 간결한 코드
    

-  객체지향 설계 원칙 SOLID
    
    -   SRP 단일 책임 원칙 (Single responsibility principle)
	    - 한 클래스는 하나의 책임만 가짐
    -   OCP 개방-폐쇄 원칙 (Open/closed principle)
	    -  소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있음
    -   LSP 리스코프 치환 원칙 (Liskov substitution principle) 
	    - 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 함
    -   ISP 인터페이스 분리 원칙 (Interface segregation principle)
	    - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 나음
    -   DIP 의존관계 역전 원칙 (Dependency inversion principle)
	    - 프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안됨
	    - 의존성 주입은 이 원칙을 따르는 방법 중 하나
    
-  컴포넌트 원칙
    -   REP 재사용/릴리즈 등가 원칙 (Reuse/Release Equivalence Principle)
        -   하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리즈 할 수 있어야 함
    -   CCP 공통 폐쇄 원칙 (Common Closure Principle)
        -   단일 컴포넌트의 변경의 이유가 여럿 있어서는 안됨
        -   동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶고, 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리
    -   CRP 공통 재사용 원칙 (Common Reuse Principle)
        -   컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라
        -   하나의 컴포넌트가 다른 컴포넌트의 단 하나의 클래스만 사용할지라도, 수십개의 클래스를 사용할때와 비교해 의존성은 달라지지 않음
        -   강하게 결합되지 않은 클래스를 동일한 컴포넌트에 위치시켜서는 안됨
    ![enter image description here](https://oopy.lazyrockets.com/api/v2/notion/image?src=https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0df965b0-2d34-4ec7-95c5-a5bf73552f02/Untitled.png&blockId=204b916f-151d-4018-a1b9-03e523526a1a)
    
    -   ADP 의존성 비순환 원칙 (Acyclic Dependencies Princple)
        -   컴포넌트 의존성 그래프에 순환(CYCLE)이 있어서는 안됨
        -   개발 환경을 릴리즈 가능한 컴포넌트 단위로 분리하는 방식
        -   개발 팀이 다른 개발 팀에 의해 영향을 받지 않을 수 있다는 이점
    -   하향식설계
        -   컴포넌트 구조는 하향식으로 설계될 수가 없다.
    -   SDP 안정된 의존성 원칙 (Stable Dependencies Principle)
        -   변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하도록 만들어서는 안됨 ⇒ 한 번 의존하게 되면, 변동성이 큰 컴포넌트도 결국 변경이 어려워지게 됨
        -   해당 원칙을 사용하여 변경하기 어려운 모듈이 변경하기 쉽게 만들어진 모듈에 의존하지 않도록 만들 수 있다.
        -   모든 컴포넌트가 안정적인 시스템이라면, 변경을 하는게 불가능 → 불안정한 컴포넌트와 안전한 컴포넌트가 적절하게 균형을 이루고 있는 구조로 설계하는게 좋다
    -   SAP 안정된 추상화 원칙
        -   안정성(Stability)과 추상화 정도(abstractness)사이의 관계를 정의
        -   안정된 컴포넌트는 추상 컴포넌트어야 한다.
            ⇒ 안정성이 컴포넌트 확장을 방해해선 안된다.
        -   불안정한 컴포넌트는 구체 컴포넌트어야 한다.
	        ⇒ 컴포넌트가 불안정하기에 내부의 구체적인 코드를 쉽게 변경할 수 있어야 한다.
            
    
    [https://catsbi.oopy.io/1088acbd-18c4-40eb-abd6-9961fe4cb46d](https://catsbi.oopy.io/1088acbd-18c4-40eb-abd6-9961fe4cb46d)
    
-  Port and adapter(헥사고날 아키텍처)
    ![enter image description here](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/Q643x/btrUEvSQdDT/GRa9uMymDhhoG0OxOT2LpK/img.png)
    
    -   장점
        1.  아키텍처 확장이 용이함
        2.  SOLID 원칙 쉽게 적용 가능
        3.  모듈 일부를 배포하는 게 용이
        4.  테스트를 위해 모듈을 가짜로 바꿀 수 있으므로 테스트가 더 안정적이고 쉬움
        5.  더 큰 비즈니스적 가치를 갖고 더 오래 지속되는 도메인 모델에 큰 관심을 둠
    -   특징
        - 어댑터(adapter): 외부에 포함된 컴포넌트를 어댑터(adapter)
        - 포트(port): 어댑터가 내부와 상호작용하는 부분            
            ⇒ 포트와 어댑터 아키텍처(패턴) 라고 불림
        - 코어에서 외부로 향하는 의존성이 없음
        - 외부 어댑터들이 목적에 맞게 포트와 잘 커뮤니케이션 되도록 구현되었다면 쉽게 교체 가능
        -  외부와 도메인 로직의 결합성(의존성)을 제거
        - 변경할 이유의 수를 줄여 유지보수성을 높임
        -   사용자 인터페이스나 데이터베이스 모두 비즈니스 로직으로부터 분리해야 하는 **외부 요소**로 취급
        -   비즈니스 로직이 **외부 요소에 의존하지 않고** 프레젠테이션 계층과 데이터 소스 계층이 **도메인 계층에 의존**하도록 만들어야 함
            
    -   계층
        -   어댑터 계층
            -   가장 바깥쪽에 있는 계층으로 애플리케이션과 다른 시스템간 상호작용 담당
            -   web 어댑터(= 웹 컨트롤러), persistence 어댑터 등이 위치함
        -   애플리케이션 계층
            -   바깥 계층에서 호출하기 위해 반드시 거쳐야하는 계층
              -   포트
                  -   서비스에서 구현될 인터페이스
                  -   input port
                      -   incoming adapter에 의해 불려집니다
                  -   output port
                      -   outgoing adapter를 부릅니다
              -   서비스
                  -   포트 구현체(= 유스케이스 구현체)
        -   도메인 계층
            -   도메인 엔티티
    
    
- 비고
    - NHN 클린아키텍처 세션 https://www.youtube.com/watch?v=g6Tg6_qpIVc
