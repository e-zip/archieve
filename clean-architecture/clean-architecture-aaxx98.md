# 클린아키텍쳐

![Untitled](https://github.com/e-zip/archieve/assets/74856502/d108afcd-c0cf-40a0-b803-6e5690e22daf)

- 클린 아키텍쳐 기본 형식

![Untitled 1](https://github.com/e-zip/archieve/assets/74856502/0d4cd56b-f9c3-4a4b-995e-8add5ec24df0)

- 3 Layered 구조로 분리한 클린 아키텍쳐

## Entity (엔티티)

- 핵심 업무 규칙을 캡슐화한다.
- 메서드를 가지는 객체, 일련의 데이터 구조와 함수의 집합이다.
- 가장 변하지 않으며 외부로부터 영향을 받지 않는 영역이다.

```
'일정'에 해당됨 '목표',
- 일정의 구성 요소 : 일정명 / 시작시간 / 종료시간 / 메모
- 일정의 메서드 (반복되어 사용되는 로직인 경우 ENTITY에 포함시키면 응집성이 높아짐)
	1. VALIDATOR - 등록 가능 여부 판단(겹치는 일정이 없는지 확인 등)
```

## Use Case (유즈케이스)

- 애플리케이션의 특화된 업무 규칙을 포함한다.
- 시스템의 모든 유즈 케이스를 캡슐화하고 구현한다.
- 엔티티로 들어오고 나가는 데이터 흐름을 조정하고 조작한다.

```
'일정'의 조회, 등록, 변경, 삭제같은 행위에 해당됨
- 등록 : 일정을 등록하기 전에 VALIDATOR 를 호출하고 등록 가능한 경우에만 등록한다.
```

## 인터페이스 어댑터(Interface Adapter)

- 일련의 어댑터들로 구성한다.
- 외부 인터페이스에서 들어오는 데이터를 유즈 케이스와 엔티티에서 처리하기 편한 방식으로 변환하며, 유즈 케이스와 엔티티에서 나가는 데이터를 외부 인터페이스에서 처리하기 편한 방식으로 변환한다.
- 컨트롤러, 프레젠터, 게이트웨이 등이 여기에 속한다.

## Framework / Driver (프레임워크와 드라이버)

- 시스템의 핵심 업무와는 관련 없는 세부 사항이다.
- 프레임워크나, 데이터베이스, 웹 서버 등이 여기에 해당한다.

## Dependency Rule (의존성 규칙)

- 의존성… 이란?
  - 변경에 의해 영향을 받는 것
  - A 객체가 B 객체를 참조하고있다 → A는 B에 의존함
  - A 객체가 B 를 지역 변수로 가지고 있다. → A는 B에 의존함
- 의존성은 밖에서 안으로 향함
- 모든 소스코드의 경계는 반드시 outer 에서 inner 로 향해야 한다.
- 바깥 원은 안쪽 원에 영향을 미치지 않음, 외부 요소의 변경에 따라 내부 요소가 받는 영향이 없어야한다.
- 경계의 바깥으로 갈수록 덜 중요하고 세부적인 영역으로 표현되며, 안으로 갈수록 고수준(좀더 추상화된 개념)으로 표현됨

```
ex) UI나 DATABASE의 변경에 의해 ENTITY 구성요소가 변경될 수 없다.
```

## Abstraction Principle (추상화 원리)

- 가장 안쪽에 있는 계층이 제일 추상화된 영역
- 바깥 영역으로 향할수록 내부 계층을 활용하여 세부 사항을 구현한다.
- 더 추상화 된 것(고수준)에 의존하면 좋은점
  - 세부 내용을 알지 않아도 참조 가능하다. → 역할을 분리하여 변경이 용이하다.

## 객체 지향 설계 원칙 (SOLID)

- SOLID 원칙의 목적: 읽기 쉽고 유지보수와 확장이 쉬운 구조

### **Single Responsibility Principle (단일책임원칙)**

- 한 클래스는 하나의 책임만 가져야함
  - 책임: 변경하려는 이유

### **Open-Closed Principle (개방폐쇄원칙)**

- 확장에 열려있고 변경에 닫혀 있는 설계
  - 기존의 코드를 변경하기 보다 새로 작성하도록 함

### **Liskov Substitution Principle (리스코프 치환법칙)**

- 자료형 S가 자료형 T의 서브타입라면 필요한 프로그램의 속성의 변경 없이 자료형 T의 객체를 자료형 S의 객체로 교체할 수 있어야 함
  - T 를 상속하는 객체 S or T 를 구현하는 객체 S로 T를 대체했을 때 프로그램이 정상적으로 동작해야함

### **Interface Segregation Principle (인터페이스 분리 원칙)**

- 클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 함
  - 큰 단위의 인터페이스에서 필요한 메서드만을 정의한 인터페이스를 만들어 사용한다.

### **Dependency Inversion Principle (의존관계 역전 원리)**

- 상위 모듈은 하위 모듈에 의존해서는 안된다. 상위 모듈과 하위 모듈 모두 추상화에 의존해야 한다.
- 추상화는 세부 사항에 의존해서는 안된다. 세부사항이 추상화에 의존해야 한다.

## 컴포넌트 원칙

- 컴포넌트: 배포 단위로 시스템의 구성요소로 배포할 수 있는 가장 작은 단위
- 배포 단위를 관리하는 방식에 적용할 수 있음

### REP (재사용/릴리즈 등가 원칙)

- 재사용 단위는 릴리즈 단위와 같다.
  - 컴포넌트가 릴리스 절차를 통해 추적 관리되지 않거나, 릴리스 번호가 부여되지 않는다면 해당 컴포넌트를 재사용할 수 없다.
  - 릴리스 번호가 없다면 재사용 컴포넌트들이 서로 호환되는 지 보증할 방법이 없다.

### CCP (공통 폐쇄 원칙)

- 컴포넌트 수준의 단일 책임 원칙
- 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트에 포함한다.
- 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리한다.

### CRP (공통 재사용 원칙)

- 강하게 결합되지 않은 클래스들을 동일한 컴포넌트에 위치시켜서는 안된다.
- 같이 재사용 되는 경향이 있는 클래스와 모듈은 같은 컴포넌트에 포함시킨다.

## 컴포넌트 결합

- 컴포넌트 사이의 관계와 개발 가능성과 논리적 설계 사이의 균형에 관한 원칙

### ADP (의존성 비순환 원칙)

- 서로 다른 컴포넌트끼리 의존하거나 의존성에 cycle 이 있으면 안된다.
- 의존도가 가장 낮은 컴포넌트를 우선으로 상향식으로 릴리즈한다.
- 순환 끊기
  - 의존성 역전 원칙(DIP)를 적용
  - cycle 을 형성한 컴포넌트들이 의존하는 새로운 컴포넌트 추가

### SDP (안정된 의존성 원칙)

- 다른 컴포넌트가 의존하고 있는 컴포넌트는 변경하기 어려워진다.
- 변동이 예상되는 컴포넌트에 의존하게 되어서는 안된다.

### SAP (안정된 추상화 원칙)

- 안정적인 컴포넌트라면 반드시 인터페이스와 추상 클래스로 구성되어 쉽게 확장할 수 있어야 한다.
- 안정적인 컴포넌트가 확장이 가능해지면 유연성을 얻게 되고 아키텍처를 과도하게 제약하지 않게 된다.

## Port and Adapter - 헥사고날 아키텍쳐

### Port

- 인터페이스 형식

### Adapter

- port 로 정의한 인터페이스의 구현체
